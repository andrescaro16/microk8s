1. Se crea vpc publica
2. Se crea grupo de seguridad publico
3 Se crean instnacias con la misma configuracion
  3.1 WP-MASTER
  3.2 WP-WORKER1
  3.3 WP-WORKER2
  3.4 WP-NFS
4. PARA TODAS LAS INSTANCIAS CONFIGURAR LO SIGUIENTE:
  * sudo apt update
  * sudo apt upgrade -y
  * sudo snap install microk8s --classic --channel=1.30/stable
  * sudo usermod -aG microk8s $USER
  * mkdir -p ~/.kube
  * sudo chown -f -R $USER ~/.kube
  * (Reiniciar terminal)
  * microk8s status --wait-ready
  * microk8s enable dashboard dns registry istio ingress
  * sudo apt install nfs-common

5. Conectar cada uno de los workers al cluster.
  5.1 En el master ejecutar este comando para establecer una conexion:
    * microk8s add-node

6. Crear NFS
  * Segui el siguiente tuturial corriendo los comandos exclusivamente para el NFS https://microk8s.io/docs/how-to-nfs

7. Agregart CSI en el nodo master para el NFS.
 * Seguir esta documentacion https://microk8s.io/docs/how-to-nfs apartado `Install the CSI driver for NFS`

8. Crear manifiestos necesarios en el master para el NFS
Necesitaremos crear los manifiestos de `StorageClass` y `PersistentVolumeClaim` usando el nfs-csi StorageClass.
  8.1 Crear StorageClass para el NFS.
  ``ADJUNTAR CODIGO``
    * Para validar que el recurso se creo de manera exitosa correr `microk8s kubectl get storageclass`
  8.2 Crear PersistentVolumeClaim usando el nfs-csi storage class.
  ``ADJUNTAR CODIGO``
    * Para validar que el recurso se creo de manera exitosa correr `microk8s kubectl get persistentvolumeclaim`

9. Configurar manifiestos de mysql
 * mkdir mysql-manifests
 * cd mysql-manifests
```ADJUNTAR CODIGO```
 * microk8s kubectl apply -f . -> Aplica todos los manifiesto, debemos esperar un momento para que se ejecute todo.
 * Validamos el estado de ejecuccion con `microk8s kubectl get pods`
 *
10. Configurar manifiestos de wordpress
* mkdir wordpress-manifests
 * cd wordpress-manifests
```ADJUNTAR CODIGO```
 * microk8s kubectl apply -f . -> Aplica todos los manifiesto, debemos esperar un momento para que se ejecute todo.
 * Validamos el estado de ejecuccion con `microk8s kubectl get pods`
 
11. Configurar manifiestos del ingress
 * mmkdir ingress
 * cd ingress

12. Configurar Certificados SSL
 * Agregar el registro para la IP pública de la máquina MASTER en nuestro servidor DNS
 * microk8s kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.crds.yaml
 * microk8s kubectl create namespace cert-manager
 * microk8s kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml
 * Validamos la creación exitosa de 3 pods con `microk8s kubectl get pods -n=cert-manager`
 * Validamos los logs `microk8s kubectl logs -n cert-manager -l app=cert-manager`
 * mkdir ssl
 * cd ssl
 * Creamos 2 claves para los archivos `cluster-issuer-staging.yaml` y `cluster-issuer.yaml` con:
   - `openssl genrsa -out letsencrypt-staging.pem 2048`
   - `openssl genrsa -out letsencrypt-private-key.pem 2048`
 * Creamos los secretos:
   - `sudo microk8s kubectl create secret generic letsencrypt-staging --from-file=letsencrypt-staging.pem`
   - `microk8s kubectl create secret generic letsencrypt-private-key --from-file=letsencrypt-private-key.pem`
 ```ADJUNTAR CÓDIGO DE AMBOS yaml```
 * microk8s kubectl apply -f cluster-issuer-staging.yaml
 * microk8s kubectl apply -f cluster-issuer.yaml
 * Validamos el estado con `microk8s kubectl get clusterissuer`
 ``ADJUNTAR CODIGO DE ingress-routes.yaml```
 * microk8s kubectl apply -f ingress-routes.yaml -> Aplicamos el manifiesto
 * microk8s kubectl get certificate -> Validamos la creación del certificado (Cuando pase a true ya podremos cambiar el `staging` del ingress-routes.yaml por `prod`)
 